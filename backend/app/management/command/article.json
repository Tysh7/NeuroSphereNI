[
    {
        "author": "Justin Lee",
        "link": "https://medium.com/swlh/chatbots-were-the-next-big-thing-what-happened-5fc49dd6fa61?source=---------0----------------",
        "title": "Chatbots were the next big thing: what happened? \u2013 The Startup \u2013 Medium",
        "text": "Oh, how the headlines blared:\nChatbots were The Next Big Thing.\nOur hopes were sky high. Bright-eyed and bushy-tailed, the industry was ripe for a new era of innovation: it was time to start socializing with machines.\nAnd why wouldn\u2019t they be? All the road signs pointed towards insane success.\nAt the Mobile World Congress 2017, chatbots were the main headliners. The conference organizers cited an \u2018overwhelming acceptance at the event of the inevitable shift of focus for brands and corporates to chatbots\u2019.\nIn fact, the only significant question around chatbots was who would monopolize the field, not whether chatbots would take off in the first place:\nOne year on, we have an answer to that question.\nNo.\nBecause there isn\u2019t even an ecosystem for a platform to dominate.\nChatbots weren\u2019t the first technological development to be talked up in grandiose terms and then slump spectacularly.\nThe age-old hype cycle unfolded in familiar fashion...\nExpectations built, built, and then..... It all kind of fizzled out.\nThe predicted paradim shift didn\u2019t materialize.\nAnd apps are, tellingly, still alive and well.\nWe look back at our breathless optimism and turn to each other, slightly baffled:\n\u201cis that it? THAT was the chatbot revolution we were promised?\u201d\nDigit\u2019s Ethan Bloch sums up the general consensus:\nAccording to Dave Feldman, Vice President of Product Design at Heap, chatbots didn\u2019t just take on one difficult problem and fail: they took on several and failed all of them.\nBots can interface with users in different ways. The big divide is text vs. speech. In the beginning (of computer interfaces) was the (written) word.\nUsers had to type commands manually into a machine to get anything done.\nThen, graphical user interfaces (GUIs) came along and saved the day. We became entranced by windows, mouse clicks, icons. And hey, we eventually got color, too!\nMeanwhile, a bunch of research scientists were busily developing natural language (NL) interfaces to databases, instead of having to learn an arcane database query language.\nAnother bunch of scientists were developing speech-processing software so that you could just speak to your computer, rather than having to type. This turned out to be a whole lot more difficult than anyone originally realised:\nThe next item on the agenda was holding a two-way dialog with a machine. Here\u2019s an example dialog (dating back to the 1990s) with VCR setup system:\nPretty cool, right? The system takes turns in collaborative way, and does a smart job of figuring out what the user wants.\nIt was carefully crafted to deal with conversations involving VCRs, and could only operate within strict limitations.\nModern day bots, whether they use typed or spoken input, have to face all these challenges, but also work in an efficient and scalable way on a variety of platforms.\nBasically, we\u2019re still trying to achieve the same innovations we were 30 years ago.\nHere\u2019s where I think we\u2019re going wrong:\nAn oversized assumption has been that apps are \u2018over\u2019, and would be replaced by bots.\nBy pitting two such disparate concepts against one another (instead of seeing them as separate entities designed to serve different purposes) we discouraged bot development.\nYou might remember a similar war cry when apps first came onto the scene ten years ago: but do you remember when apps replaced the internet?\nIt\u2019s said that a new product or service needs to be two of the following: better, cheaper, or faster. Are chatbots cheaper or faster than apps? No \u2014 not yet, at least.\nWhether they\u2019re \u2018better\u2019 is subjective, but I think it\u2019s fair to say that today\u2019s best bot isn\u2019t comparable to today\u2019s best app.\nPlus, nobody thinks that using Lyft is too complicated, or that it\u2019s too hard to order food or buy a dress on an app. What is too complicated is trying to complete these tasks with a bot \u2014 and having the bot fail.\nA great bot can be about as useful as an average app. When it comes to rich, sophisticated, multi-layered apps, there\u2019s no competition.\nThat\u2019s because machines let us access vast and complex information systems, and the early graphical information systems were a revolutionary leap forward in helping us locate those systems.\nModern-day apps benefit from decades of research and experimentation. Why would we throw this away?\nBut, if we swap the word \u2018replace\u2019 with \u2018extend\u2019, things get much more interesting.\nToday\u2019s most successful bot experiences take a hybrid approach, incorporating chat into a broader strategy that encompasses more traditional elements.\nThe next wave will be multimodal apps, where you can say what you want (like with Siri) and get back information as a map, text, or even a spoken response.\nAnother problematic aspect of the sweeping nature of hype is that it tends to bypass essential questions like these.\nFor plenty of companies, bots just aren\u2019t the right solution. The past two years are littered with cases of bots being blindly applied to problems where they aren\u2019t needed.\nBuilding a bot for the sake of it, letting it loose and hoping for the best will never end well:\nThe vast majority of bots are built using decision-tree logic, where the bot\u2019s canned response relies on spotting specific keywords in the user input.\nThe advantage of this approach is that it\u2019s pretty easy to list all the cases that they are designed to cover. And that\u2019s precisely their disadvantage, too.\nThat\u2019s because these bots are purely a reflection of the capability, fastidiousness and patience of the person who created them; and how many user needs and inputs they were able to anticipate.\nProblems arise when life refuses to fit into those boxes.\nAccording to recent reports, 70% of the 100,000+ bots on Facebook Messenger are failing to fulfil simple user requests. This is partly a result of developers failing to narrow their bot down to one strong area of focus.\nWhen we were building GrowthBot, we decided to make it specific to sales and marketers: not an \u2018all-rounder\u2019, despite the temptation to get overexcited about potential capabilties.\nRemember: a bot that does ONE thing well is infinitely more helpful than a bot that does multiple things poorly.\nA competent developer can build a basic bot in minutes \u2014 but one that can hold a conversation? That\u2019s another story. Despite the constant hype around AI, we\u2019re still a long way from achieving anything remotely human-like.\nIn an ideal world, the technology known as NLP (natural language processing) should allow a chatbot to understand the messages it receives. But NLP is only just emerging from research labs and is very much in its infancy.\nSome platforms provide a bit of NLP, but even the best is at toddler-level capacity (for example, think about Siri understanding your words, but not their meaning.)\nAs Matt Asay outlines, this results in another issue: failure to capture the attention and creativity of developers.\nAnd conversations are complex. They\u2019re not linear. Topics spin around each other, take random turns, restart or abruptly finish.\nToday\u2019s rule-based dialogue systems are too brittle to deal with this kind of unpredictability, and statistical approaches using machine learning are just as limited. The level of AI required for human-like conversation just isn\u2019t available yet.\nAnd in the meantime, there are few high-quality examples of trailblazing bots to lead the way. As Dave Feldman remarked:\nOnce upon a time, the only way to interact with computers was by typing arcane commands to the terminal. Visual interfaces using windows, icons or a mouse were a revolution in how we manipulate information\nThere\u2019s a reasons computing moved from text-based to graphical user interfaces (GUIs). On the input side, it\u2019s easier and faster to click than it is to type.\nTapping or selecting is obviously preferable to typing out a whole sentence, even with predictive (often error-prone ) text. On the output side, the old adage that a picture is worth a thousand words is usually true.\nWe love optical displays of information because we are highly visual creatures. It\u2019s no accident that kids love touch screens. The pioneers who dreamt up graphical interface were inspired by cognitive psychology, the study of how the brain deals with communication.\nConversational UIs are meant to replicate the way humans prefer to communicate, but they end up requiring extra cognitive effort. Essentially, we\u2019re swapping something simple for a more-complex alternative.\nSure, there are some concepts that we can only express using language (\u201cshow me all the ways of getting to a museum that give me 2000 steps but don\u2019t take longer than 35 minutes\u201d), but most tasks can be carried out more efficiently and intuitively with GUIs than with a conversational UI.\nAiming for a human dimension in business interactions makes sense.\nIf there\u2019s one thing that\u2019s broken about sales and marketing, it\u2019s the lack of humanity: brands hide behind ticket numbers, feedback forms, do-not-reply-emails, automated responses and gated \u2018contact us\u2019 forms.\nFacebook\u2019s goal is that their bots should pass the so-called Turing Test, meaning you can\u2019t tell whether you are talking to a bot or a human. But a bot isn\u2019t the same as a human. It never will be.\nA conversation encompasses so much more than just text.\nHumans can read between the lines, leverage contextual information and understand double layers like sarcasm. Bots quickly forget what they\u2019re talking about, meaning it\u2019s a bit like conversing with someone who has little or no short-term memory.\nAs HubSpot team pinpointed:\nPeople aren\u2019t easily fooled, and pretending a bot is a human is guaranteed to diminish returns (not to mention the fact that you\u2019re lying to your users).\nAnd even those rare bots that are powered by state-of-the-art NLP, and excel at processing and producing content, will fall short in comparison.\nAnd here\u2019s the other thing. Conversational UIs are built to replicate the way humans prefer to communicate \u2014 with other humans.\nBut is that how humans prefer to interact with machines?\nNot necessarily.\nAt the end of the day, no amount of witty quips or human-like mannerisms will save a bot from conversational failure.\nIn a way, those early-adopters weren\u2019t entirely wrong.\nPeople are yelling at Google Home to play their favorite song, ordering pizza from the Domino\u2019s bot and getting makeup tips from Sephora. But in terms of consumer response and developer involvement, chatbots haven\u2019t lived up to the hype generated circa 2015/16.\nNot even close.\nComputers are good at being computers. Searching for data, crunching numbers, analyzing opinions and condensing that information.\nComputers aren\u2019t good at understanding human emotion. The state of NLP means they still don\u2019t \u2018get\u2019 what we\u2019re asking them, never mind how we feel.\nThat\u2019s why it\u2019s still impossible to imagine effective customer support, sales or marketing without the essential human touch: empathy and emotional intelligence.\nFor now, bots can continue to help us with automated, repetitive, low-level tasks and queries; as cogs in a larger, more complex system. And we did them, and ourselves, a disservice by expecting so much, so soon.\nBut that\u2019s not the whole story.\nYes, our industry massively overestimated the initial impact chatbots would have. Emphasis on initial.\nAs Bill Gates once said:\nThe hype is over. And that\u2019s a good thing. Now, we can start examining the middle-grounded grey area, instead of the hyper-inflated, frantic black and white zone.\nI believe we\u2019re at the very beginning of explosive growth. This sense of anti-climax is completely normal for transformational technology.\nMessaging will continue to gain traction. Chatbots aren\u2019t going away. NLP and AI are becoming more sophisticated every day.\nDevelopers, apps and platforms will continue to experiment with, and heavily invest in, conversational marketing.\nAnd I can\u2019t wait to see what happens next.\nFrom a quick cheer to a standing ovation, clap to show how much you enjoyed this story.\nHead of Growth for GrowthBot, Messaging & Conversational Strategy @HubSpot\nMedium's largest publication for makers. Subscribe to receive our top stories here \u2192 https://goo.gl/zHcLJi"
    },
    {
        "author": "Conor Dewey",
        "link": "https://towardsdatascience.com/python-for-data-science-8-concepts-you-may-have-forgotten-i-did-825966908393?source=---------1----------------",
        "title": "Python for Data Science: 8 Concepts You May Have Forgotten",
        "text": "If you\u2019ve ever found yourself looking up the same question, concept, or syntax over and over again when programming, you\u2019re not alone.\nI find myself doing this constantly.\nWhile it\u2019s not unnatural to look things up on StackOverflow or other resources, it does slow you down a good bit and raise questions as to your complete understanding of the language.\nWe live in a world where there is a seemingly infinite amount of accessible, free resources looming just one search away at all times. However, this can be both a blessing and a curse. When not managed effectively, an over-reliance on these resources can build poor habits that will set you back long-term.\nPersonally, I find myself pulling code from similar discussion threads several times, rather than taking the time to learn and solidify the concept so that I can reproduce the code myself the next time.\nThis approach is lazy and while it may be the path of least resistance in the short-term, it will ultimately hurt your growth, productivity, and ability to recall syntax (cough, interviews) down the line.\nRecently, I\u2019ve been working through an online data science course titled Python for Data Science and Machine Learning on Udemy (Oh God, I sound like that guy on Youtube). Over the early lectures in the series, I was reminded of some concepts and syntax that I consistently overlook when performing data analysis in Python.\nIn the interest of solidifying my understanding of these concepts once and for all and saving you guys a couple of StackOverflow searches, here\u2019s the stuff that I\u2019m always forgetting when working with Python, NumPy, and Pandas.\nI\u2019ve included a short description and example for each, however for your benefit, I will also include links to videos and other resources that explore each concept more in-depth as well.\nWriting out a for loop every time you need to define some sort of list is tedious, luckily Python has a built-in way to address this problem in just one line of code. The syntax can be a little hard to wrap your head around but once you get familiar with this technique you\u2019ll use it fairly often.\nSee the example above and below for how you would normally go about list comprehension with a for loop vs. creating your list with in one simple line with no loops necessary.\nEver get tired of creating function after function for limited use cases? Lambda functions to the rescue! Lambda functions are used for creating small, one-time and anonymous function objects in Python. Basically, they let you create a function, without creating a function.\nThe basic syntax of lambda functions is:\nNote that lambda functions can do everything that regular functions can do, as long as there\u2019s just one expression. Check out the simple example below and the upcoming video to get a better feel for the power of lambda functions:\nOnce you have a grasp on lambda functions, learning to pair them with the map and filter functions can be a powerful tool.\nSpecifically, map takes in a list and transforms it into a new list by performing some sort of operation on each element. In this example, it goes through each element and maps the result of itself times 2 to a new list. Note that the list function simply converts the output to list type.\nThe filter function takes in a list and a rule, much like map, however it returns a subset of the original list by comparing each element against the boolean filtering rule.\nFor creating quick and easy Numpy arrays, look no further than the arange and linspace functions. Each one has their specific purpose, but the appeal here (instead of using range), is that they output NumPy arrays, which are typically easier to work with for data science.\nArange returns evenly spaced values within a given interval. Along with a starting and stopping point, you can also define a step size or data type if necessary. Note that the stopping point is a \u2018cut-off\u2019 value, so it will not be included in the array output.\nLinspace is very similar, but with a slight twist. Linspace returns evenly spaced numbers over a specified interval. So given a starting and stopping point, as well as a number of values, linspace will evenly space them out for you in a NumPy array. This is especially helpful for data visualizations and declaring axes when plotting.\nYou may have ran into this when dropping a column in Pandas or summing values in NumPy matrix. If not, then you surely will at some point. Let\u2019s use the example of dropping a column for now:\nI don\u2019t know how many times I wrote this line of code before I actually knew why I was declaring axis what I was. As you can probably deduce from above, set axis to 1 if you want to deal with columns and set it to 0 if you want rows. But why is this? My favorite reasoning, or atleast how I remember this:\nCalling the shape attribute from a Pandas dataframe gives us back a tuple with the first value representing the number of rows and the second value representing the number of columns. If you think about how this is indexed in Python, rows are at 0 and columns are at 1, much like how we declare our axis value. Crazy, right?\nIf you\u2019re familiar with SQL, then these concepts will probably come a lot easier for you. Anyhow, these functions are essentially just ways to combine dataframes in specific ways. It can be difficult to keep track of which is best to use at which time, so let\u2019s review it.\nConcat allows the user to append one or more dataframes to each other either below or next to it (depending on how you define the axis).\nMerge combines multiple dataframes on specific, common columns that serve as the primary key.\nJoin, much like merge, combines two dataframes. However, it joins them based on their indices, rather than some specified column.\nCheck out the excellent Pandas documentation for specific syntax and more concrete examples, as well as some special cases that you may run into.\nThink of apply as a map function, but made for Pandas DataFrames or more specifically, for Series. If you\u2019re not as familiar, Series are pretty similar to NumPy arrays for the most part.\nApply sends a function to every element along a column or row depending on what you specify. You might imagine how useful this can be, especially for formatting and manipulating values across a whole DataFrame column, without having to loop at all.\nLast but certainly not least is pivot tables. If you\u2019re familiar with Microsoft Excel, then you\u2019ve probably heard of pivot tables in some respect. The Pandas built-in pivot_table function creates a spreadsheet-style pivot table as a DataFrame. Note that the levels in the pivot table are stored in MultiIndex objects on the index and columns of the resulting DataFrame.\nThat\u2019s it for now. I hope a couple of these overviews have effectively jogged your memory regarding important yet somewhat tricky methods, functions, and concepts you frequently encounter when using Python for data science. Personally, I know that even the act of writing these out and trying to explain them in simple terms has helped me out a ton.\nIf you\u2019re interested in receiving my weekly rundown of interesting articles and resources focused on data science, machine learning, and artificial intelligence, then subscribe to Self Driven Data Science using the form below!\nIf you enjoyed this post, feel free to hit the clap button and if you\u2019re interested in posts to come, make sure to follow me on Medium at the link below \u2014 I\u2019ll be writing and shipping every day this month as part of a 30-Day Challenge.\nThis article was originally published on conordewey.com\nFrom a quick cheer to a standing ovation, clap to show how much you enjoyed this story.\nData Scientist & Writer | www.conordewey.com\nSharing concepts, ideas, and codes."
    },
    {
        "author": "William Koehrsen",
        "link": "https://towardsdatascience.com/automated-feature-engineering-in-python-99baf11cc219?source=---------2----------------",
        "title": "Automated Feature Engineering in Python \u2013 Towards Data Science",
        "text": "Machine learning is increasingly moving from hand-designed models to automatically optimized pipelines using tools such as H20, TPOT, and auto-sklearn. These libraries, along with methods such as random search, aim to simplify the model selection and tuning parts of machine learning by finding the best model for a dataset with little to no manual intervention. However, feature engineering, an arguably more valuable aspect of the machine learning pipeline, remains almost entirely a human labor.\nFeature engineering, also known as feature creation, is the process of constructing new features from existing data to train a machine learning model. This step can be more important than the actual model used because a machine learning algorithm only learns from the data we give it, and creating features that are relevant to a task is absolutely crucial (see the excellent paper \u201cA Few Useful Things to Know about Machine Learning\u201d).\nTypically, feature engineering is a drawn-out manual process, relying on domain knowledge, intuition, and data manipulation. This process can be extremely tedious and the final features will be limited both by human subjectivity and time. Automated feature engineering aims to help the data scientist by automatically creating many candidate features out of a dataset from which the best can be selected and used for training.\nIn this article, we will walk through an example of using automated feature engineering with the featuretools Python library. We will use an example dataset to show the basics (stay tuned for future posts using real-world data). The complete code for this article is available on GitHub.\nFeature engineering means building additional features out of existing data which is often spread across multiple related tables. Feature engineering requires extracting the relevant information from the data and getting it into a single table which can then be used to train a machine learning model.\nThe process of constructing features is very time-consuming because each new feature usually requires several steps to build, especially when using information from more than one table. We can group the operations of feature creation into two categories: transformations and aggregations. Let\u2019s look at a few examples to see these concepts in action.\nA transformation acts on a single table (thinking in terms of Python, a table is just a Pandas DataFrame ) by creating new features out of one or more of the existing columns. As an example, if we have the table of clients below\nwe can create features by finding the month of the joined column or taking the natural log of the income column. These are both transformations because they use information from only one table.\nOn the other hand, aggregations are performed across tables, and use a one-to-many relationship to group observations and then calculate statistics. For example, if we have another table with information on the loans of clients, where each client may have multiple loans, we can calculate statistics such as the average, maximum, and minimum of loans for each client.\nThis process involves grouping the loans table by the client, calculating the aggregations, and then merging the resulting data into the client data. Here\u2019s how we would do that in Python using the language of Pandas.\nThese operations are not difficult by themselves, but if we have hundreds of variables spread across dozens of tables, this process is not feasible to do by hand. Ideally, we want a solution that can automatically perform transformations and aggregations across multiple tables and combine the resulting data into a single table. Although Pandas is a great resource, there\u2019s only so much data manipulation we want to do by hand! (For more on manual feature engineering check out the excellent Python Data Science Handbook).\nFortunately, featuretools is exactly the solution we are looking for. This open-source Python library will automatically create many features from a set of related tables. Featuretools is based on a method known as \u201cDeep Feature Synthesis\u201d, which sounds a lot more imposing than it actually is (the name comes from stacking multiple features not because it uses deep learning!).\nDeep feature synthesis stacks multiple transformation and aggregation operations (which are called feature primitives in the vocab of featuretools) to create features from data spread across many tables. Like most ideas in machine learning, it\u2019s a complex method built on a foundation of simple concepts. By learning one building block at a time, we can form a good understanding of this powerful method.\nFirst, let\u2019s take a look at our example data. We already saw some of the dataset above, and the complete collection of tables is as follows:\nIf we have a machine learning task, such as predicting whether a client will repay a future loan, we will want to combine all the information about clients into a single table. The tables are related (through the client_id and the loan_id variables) and we could use a series of transformations and aggregations to do this process by hand. However, we will shortly see that we can instead use featuretools to automate the process.\nThe first two concepts of featuretools are entities and entitysets. An entity is simply a table (or a DataFrame if you think in Pandas). An EntitySet is a collection of tables and the relationships between them. Think of an entityset as just another Python data structure, with its own methods and attributes.\nWe can create an empty entityset in featuretools using the following:\nNow we have to add entities. Each entity must have an index, which is a column with all unique elements. That is, each value in the index must appear in the table only once. The index in the clients dataframe is the client_idbecause each client has only one row in this dataframe. We add an entity with an existing index to an entityset using the following syntax:\nThe loans dataframe also has a unique index, loan_id and the syntax to add this to the entityset is the same as for clients. However, for the payments dataframe, there is no unique index. When we add this entity to the entityset, we need to pass in the parameter make_index = True and specify the name of the index. Also, although featuretools will automatically infer the data type of each column in an entity, we can override this by passing in a dictionary of column types to the parameter variable_types .\nFor this dataframe, even though missed is an integer, this is not a numeric variable since it can only take on 2 discrete values, so we tell featuretools to treat is as a categorical variable. After adding the dataframes to the entityset, we inspect any of them:\nThe column types have been correctly inferred with the modification we specified. Next, we need to specify how the tables in the entityset are related.\nThe best way to think of a relationship between two tables is the analogy of parent to child. This is a one-to-many relationship: each parent can have multiple children. In the realm of tables, a parent table has one row for every parent, but the child table may have multiple rows corresponding to multiple children of the same parent.\nFor example, in our dataset, the clients dataframe is a parent of the loans dataframe. Each client has only one row in clients but may have multiple rows in loans. Likewise, loans is the parent of payments because each loan will have multiple payments. The parents are linked to their children by a shared variable. When we perform aggregations, we group the child table by the parent variable and calculate statistics across the children of each parent.\nTo formalize a relationship in featuretools, we only need to specify the variable that links two tables together. The clients and the loans table are linked via the client_id variable and loans and payments are linked with the loan_id. The syntax for creating a relationship and adding it to the entityset are shown below:\nThe entityset now contains the three entities (tables) and the relationships that link these entities together. After adding entities and formalizing relationships, our entityset is complete and we are ready to make features.\nBefore we can quite get to deep feature synthesis, we need to understand feature primitives. We already know what these are, but we have just been calling them by different names! These are simply the basic operations that we use to form new features:\nNew features are created in featuretools using these primitives either by themselves or stacking multiple primitives. Below is a list of some of the feature primitives in featuretools (we can also define custom primitives):\nThese primitives can be used by themselves or combined to create features. To make features with specified primitives we use the ft.dfs function (standing for deep feature synthesis). We pass in the entityset, the target_entity , which is the table where we want to add the features, the selected trans_primitives (transformations), and agg_primitives (aggregations):\nThe result is a dataframe of new features for each client (because we made clients the target_entity). For example, we have the month each client joined which is a transformation feature primitive:\nWe also have a number of aggregation primitives such as the average payment amounts for each client:\nEven though we specified only a few feature primitives, featuretools created many new features by combining and stacking these primitives.\nThe complete dataframe has 793 columns of new features!\nWe now have all the pieces in place to understand deep feature synthesis (dfs). In fact, we already performed dfs in the previous function call! A deep feature is simply a feature made of stacking multiple primitives and dfs is the name of process that makes these features. The depth of a deep feature is the number of primitives required to make the feature.\nFor example, the MEAN(payments.payment_amount) column is a deep feature with a depth of 1 because it was created using a single aggregation. A feature with a depth of two is LAST(loans(MEAN(payments.payment_amount)) This is made by stacking two aggregations: LAST (most recent) on top of MEAN. This represents the average payment size of the most recent loan for each client.\nWe can stack features to any depth we want, but in practice, I have never gone beyond a depth of 2. After this point, the features are difficult to interpret, but I encourage anyone interested to try \u201cgoing deeper\u201d.\nWe do not have to manually specify the feature primitives, but instead can let featuretools automatically choose features for us. To do this, we use the same ft.dfs function call but do not pass in any feature primitives:\nFeaturetools has built many new features for us to use. While this process does automatically create new features, it will not replace the data scientist because we still have to figure out what to do with all these features. For example, if our goal is to predict whether or not a client will repay a loan, we could look for the features most correlated with a specified outcome. Moreover, if we have domain knowledge, we can use that to choose specific feature primitives or seed deep feature synthesis with candidate features.\nAutomated feature engineering has solved one problem, but created another: too many features. Although it\u2019s difficult to say before fitting a model which of these features will be important, it\u2019s likely not all of them will be relevant to a task we want to train our model on. Moreover, having too many features can lead to poor model performance because the less useful features drown out those that are more important.\nThe problem of too many features is known as the curse of dimensionality. As the number of features increases (the dimension of the data grows) it becomes more and more difficult for a model to learn the mapping between features and targets. In fact, the amount of data needed for the model to perform well scales exponentially with the number of features.\nThe curse of dimensionality is combated with feature reduction (also known as feature selection): the process of removing irrelevant features. This can take on many forms: Principal Component Analysis (PCA), SelectKBest, using feature importances from a model, or auto-encoding using deep neural networks. However, feature reduction is a different topic for another article. For now, we know that we can use featuretools to create numerous features from many tables with minimal effort!\nLike many topics in machine learning, automated feature engineering with featuretools is a complicated concept built on simple ideas. Using concepts of entitysets, entities, and relationships, featuretools can perform deep feature synthesis to create new features. Deep feature synthesis in turn stacks feature primitives \u2014 aggregations, which act across a one-to-many relationship between tables, and transformations, functions applied to one or more columns in a single table \u2014 to build new features from multiple tables.\nIn future articles, I\u2019ll show how to use this technique on a real world problem, the Home Credit Default Risk competition currently being hosted on Kaggle. Stay tuned for that post, and in the meantime, read this introduction to get started in the competition! I hope that you can now use automated feature engineering as an aid in a data science pipeline. Our models are only as good as the data we give them, and automated feature engineering can help to make the feature creation process more efficient.\nFor more information on featuretools, including advanced usage, check out the online documentation. To see how featuretools is used in practice, read about the work of Feature Labs, the company behind the open-source library.\nAs always, I welcome feedback and constructive criticism and can be reached on Twitter @koehrsen_will.\nFrom a quick cheer to a standing ovation, clap to show how much you enjoyed this story.\nData Scientist and Master Student, Data Science Communicator and Advocate\nSharing concepts, ideas, and codes."
    },
    {
        "author": "Gant Laborde",
        "link": "https://medium.freecodecamp.org/machine-learning-how-to-go-from-zero-to-hero-40e26f8aa6da?source=---------3----------------",
        "title": "Machine Learning: how to go from Zero to Hero \u2013 freeCodeCamp",
        "text": "If your understanding of A.I. and Machine Learning is a big question mark, then this is the blog post for you. Here, I gradually increase your AwesomenessicityTM by gluing inspirational videos together with friendly text.\nSit down and relax. These videos take time, and if they don\u2019t inspire you to continue to the next section, fair enough.\nHowever, if you find yourself at the bottom of this article, you\u2019ve earned your well-rounded knowledge and passion for this new world. Where you go from there is up to you.\nA.I. was always cool, from moving a paddle in Pong to lighting you up with combos in Street Fighter.\nA.I. has always revolved around a programmer\u2019s functional guess at how something should behave. Fun, but programmers aren\u2019t always gifted in programming A.I. as we often see. Just Google \u201cepic game fails\u201d to see glitches in A.I., physics, and sometimes even experienced human players.\nRegardless, A.I. has a new talent. You can teach a computer to play video games, understand language, and even how to identify people or things. This tip-of-the-iceberg new skill comes from an old concept that only recently got the processing power to exist outside of theory.\nI\u2019m talking about Machine Learning.\nYou don\u2019t need to come up with advanced algorithms anymore. You just have to teach a computer to come up with its own advanced algorithm.\nSo how does something like that even work? An algorithm isn\u2019t really written as much as it is sort of... bred. I\u2019m not using breeding as an analogy. Watch this short video, which gives excellent commentary and animations to the high-level concept of creating the A.I.\nWow! Right? That\u2019s a crazy process!\nNow how is it that we can\u2019t even understand the algorithm when it\u2019s done? One great visual was when the A.I. was written to beat Mario games. As a human, we all understand how to play a side-scroller, but identifying the predictive strategy of the resulting A.I. is insane.\nImpressed? There\u2019s something amazing about this idea, right? The only problem is we don\u2019t know Machine Learning, and we don\u2019t know how to hook it up to video games.\nFortunately for you, Elon Musk already provided a non-profit company to do the latter. Yes, in a dozen lines of code you can hook up any A.I. you want to countless games/tasks!\nI have two good answers on why you should care. Firstly, Machine Learning (ML) is making computers do things that we\u2019ve never made computers do before. If you want to do something new, not just new to you, but to the world, you can do it with ML.\nSecondly, if you don\u2019t influence the world, the world will influence you.\nRight now significant companies are investing in ML, and we\u2019re already seeing it change the world. Thought-leaders are warning that we can\u2019t let this new age of algorithms exist outside of the public eye. Imagine if a few corporate monoliths controlled the Internet. If we don\u2019t take up arms, the science won\u2019t be ours. I think Christian Heilmann said it best in his talk on ML.\nThe concept is useful and cool. We understand it at a high level, but what the heck is actually happening? How does this work?\nIf you want to jump straight in, I suggest you skip this section and move on to the next \u201cHow Do I Get Started\u201d section. If you\u2019re motivated to be a DOer in ML, you won\u2019t need these videos.\nIf you\u2019re still trying to grasp how this could even be a thing, the following video is perfect for walking you through the logic, using the classic ML problem of handwriting.\nPretty cool huh? That video shows that each layer gets simpler rather than more complicated. Like the function is chewing data into smaller pieces that end in an abstract concept. You can get your hands dirty in interacting with this process on this site (by Adam Harley).\nIt\u2019s cool watching data go through a trained model, but you can even watch your neural network get trained.\nOne of the classic real-world examples of Machine Learning in action is the iris data set from 1936. In a presentation I attended by JavaFXpert\u2019s overview on Machine Learning, I learned how you can use his tool to visualize the adjustment and back propagation of weights to neurons on a neural network. You get to watch it train the neural model!\nEven if you\u2019re not a Java buff, the presentation Jim gives on all things Machine Learning is a pretty cool 1.5+ hour introduction into ML concepts, which includes more info on many of the examples above.\nThese concepts are exciting! Are you ready to be the Einstein of this new era? Breakthroughs are happening every day, so get started now.\nThere are tons of resources available. I\u2019ll be recommending two approaches.\nIn this approach, you\u2019ll understand Machine Learning down to the algorithms and the math. I know this way sounds tough, but how cool would it be to really get into the details and code this stuff from scratch!\nIf you want to be a force in ML, and hold your own in deep conversations, then this is the route for you.\nI recommend that you try out Brilliant.org\u2019s app (always great for any science lover) and take the Artificial Neural Network course. This course has no time limits and helps you learn ML while killing time in line on your phone.\nThis one costs money after Level 1.\nCombine the above with simultaneous enrollment in Andrew Ng\u2019s Stanford course on \u201cMachine Learning in 11 weeks\u201d. This is the course that Jim Weaver recommended in his video above. I\u2019ve also had this course independently suggested to me by Jen Looper.\nEveryone provides a caveat that this course is tough. For some of you that\u2019s a show stopper, but for others, that\u2019s why you\u2019re going to put yourself through it and collect a certificate saying you did.\nThis course is 100% free. You only have to pay for a certificate if you want one.\nWith those two courses, you\u2019ll have a LOT of work to do. Everyone should be impressed if you make it through because that\u2019s not simple.\nBut more so, if you do make it through, you\u2019ll have a deep understanding of the implementation of Machine Learning that will catapult you into successfully applying it in new and world-changing ways.\nIf you\u2019re not interested in writing the algorithms, but you want to use them to create the next breathtaking website/app, you should jump into TensorFlow and the crash course.\nTensorFlow is the de facto open-source software library for machine learning. It can be used in countless ways and even with JavaScript. Here\u2019s a crash course.\nPlenty more information on available courses and rankings can be found here.\nIf taking a course is not your style, you\u2019re still in luck. You don\u2019t have to learn the nitty-gritty of ML in order to use it today. You can efficiently utilize ML as a service in many ways with tech giants who have trained models ready.\nI would still caution you that there\u2019s no guarantee that your data is safe or even yours, but the offerings of services for ML are quite attractive!\nUsing an ML service might be the best solution for you if you\u2019re excited and able to upload your data to Amazon/Microsoft/Google. I like to think of these services as a gateway drug to advanced ML. Either way, it\u2019s good to get started now.\nI have to say thank you to all the aforementioned people and videos. They were my inspiration to get started, and though I\u2019m still a newb in the ML world, I\u2019m happy to light the path for others as we embrace this awe-inspiring age we find ourselves in.\nIt\u2019s imperative to reach out and connect with people if you take up learning this craft. Without friendly faces, answers, and sounding boards, anything can be hard. Just being able to ask and get a response is a game changer. Add me, and add the people mentioned above. Friendly people with friendly advice helps!\nSee?\nI hope this article has inspired you and those around you to learn ML!\nFrom a quick cheer to a standing ovation, clap to show how much you enjoyed this story.\nSoftware Consultant, Adjunct Professor, Published Author, Award Winning Speaker, Mentor, Organizer and Immature Nerd :D \u2014 Lately full of React Native Tech\nOur community publishes stories worth reading on development, design, and data science."
    },
    {
        "author": "Emmanuel Ameisen",
        "link": "https://blog.insightdatascience.com/reinforcement-learning-from-scratch-819b65f074d8?source=---------4----------------",
        "title": "Reinforcement Learning from scratch \u2013 Insight Data",
        "text": "Want to learn about applied Artificial Intelligence from leading practitioners in Silicon Valley, New York, or Toronto? Learn more about the Insight Artificial Intelligence Fellows Program.\nAre you a company working in AI and would like to get involved in the Insight AI Fellows Program? Feel free to get in touch.\nRecently, I gave a talk at the O\u2019Reilly AI conference in Beijing about some of the interesting lessons we\u2019ve learned in the world of NLP. While there, I was lucky enough to attend a tutorial on Deep Reinforcement Learning (Deep RL) from scratch by Unity Technologies. I thought that the session, led by Arthur Juliani, was extremely informative and wanted to share some big takeaways below.\nIn our conversations with companies, we\u2019ve seen a rise of interesting Deep RL applications, tools and results. In parallel, the inner workings and applications of Deep RL, such as AlphaGo pictured above, can often seem esoteric and hard to understand. In this post, I will give an overview of core aspects of the field that can be understood by anyone.\nMany of the visuals are from the slides of the talk, and some are new. The explanations and opinions are mine. If anything is unclear, reach out to me here!\nDeep RL is a field that has seen vast amounts of research interest, including learning to play Atari games, beating pro players at Dota 2, and defeating Go champions. Contrary to many classical Deep Learning problems that often focus on perception (does this image contain a stop sign?), Deep RL adds the dimension of actions that influence the environment (what is the goal, and how do I get there?). In dialog systems for example, classical Deep Learning aims to learn the right response for a given query. On the other hand, Deep Reinforcement Learning focuses on the right sequences of sentences that will lead to a positive outcome, for example a happy customer.\nThis makes Deep RL particularly attractive for tasks that require planning and adaptation, such as manufacturing or self-driving. However, industry applications have trailed behind the rapidly advancing results coming out of the research community. A major reason is that Deep RL often requires an agent to experiment millions of times before learning anything useful. The best way to do this rapidly is by using a simulation environment. This tutorial will be using Unity to create environments to train agents in.\nFor this workshop led by Arthur Juliani and Leon Chen, their goal was to get every participants to successfully train multiple Deep RL algorithms in 4 hours. A tall order! Below, is a comprehensive overview of many of the main algorithms that power Deep RL today. For a more complete set of tutorials, Arthur Juliani wrote an 8-part series starting here.\nDeep RL can be used to best the top human players at Go, but to understand how that\u2019s done, you first need to understand a few simple concepts, starting with much easier problems.\n1/It all starts with slot machines\nLet\u2019s imagine you are faced with 4 chests that you can pick from at each turn. Each of them have a different average payout, and your goal is to maximize the total payout you receive after a fixed number of turns. This is a classic problem called Multi-armed bandits and is where we will start. The crux of the problem is to balance exploration, which helps us learn about which states are good, and exploitation, where we now use what we know to pick the best slot machine.\nHere, we will utilize a value function that maps our actions to an estimated reward, called the Q function. First, we\u2019ll initialize all Q values at equal values. Then, we\u2019ll update the Q value of each action (picking each chest) based on how good the payout was after choosing this action. This allows us to learn a good value function. We will approximate our Q function using a neural network (starting with a very shallow one) that learns a probability distribution (by using a softmax) over the 4 potential chests.\nWhile the value function tells us how good we estimate each action to be, the policy is the function that determines which actions we end up taking. Intuitively, we might want to use a policy that picks the action with the highest Q value. This performs poorly in practice, as our Q estimates will be very wrong at the start before we gather enough experience through trial and error. This is why we need to add a mechanism to our policy to encourage exploration. One way to do that is to use epsilon greedy, which consists of taking a random action with probability epsilon. We start with epsilon being close to 1, always choosing random actions, and lower epsilon as we go along and learn more about which chests are good. Eventually, we learn which chests are best.\nIn practice, we might want to take a more subtle approach than either taking the action we think is the best, or a random action. A popular method is Boltzmann Exploration, which adjust probabilities based on our current estimate of how good each chest is, adding in a randomness factor.\n2/Adding different states\nThe previous example was a world in which we were always in the same state, waiting to pick from the same 4 chests in front of us. Most real-word problems consist of many different states. That is what we will add to our environment next. Now, the background behind chests alternates between 3 colors at each turn, changing the average values of the chests. This means we need to learn a Q function that depends not only on the action (the chest we pick), but the state (what the color of the background is). This version of the problem is called Contextual Multi-armed Bandits.\nSurprisingly, we can use the same approach as before. The only thing we need to add is an extra dense layer to our neural network, that will take in as input a vector representing the current state of the world.\n3/Learning about the consequences of our actions\nThere is another key factor that makes our current problem simpler than mosts. In most environments, such as in the maze depicted above, the actions that we take have an impact on the state of the world. If we move up on this grid, we might receive a reward or we might receive nothing, but the next turn we will be in a different state. This is where we finally introduce a need for planning.\nFirst, we will define our Q function as the immediate reward in our current state, plus the discounted reward we are expecting by taking all of our future actions. This solution works if our Q estimate of states is accurate, so how can we learn a good estimate?\nWe will use a method called Temporal Difference (TD) learning to learn a good Q function. The idea is to only look at a limited number of steps in the future. TD(1) for example, only uses the next 2 states to evaluate the reward.\nSurprisingly, we can use TD(0), which looks at the current state, and our estimate of the reward the next turn, and get great results. The structure of the network is the same, but we need to go through one forward step before receiving the error. We then use this error to back propagate gradients, like in traditional Deep Learning, and update our value estimates.\n3+/Introducing Monte Carlo\nAnother method to estimate the eventual success of our actions is Monte Carlo Estimates. This consists of playing out the entire episode with our current policy until we reach an end (success by reaching a green block or failure by reaching a red block in the image above) and use that result to update our value estimates for each traversed state. This allows us to propagate values efficiently in one batch at the end of an episode, instead of every time we make a move. The cost is that we are introducing noise to our estimates, since we attribute very distant rewards to them.\n4/The world is rarely discrete\nThe previous methods were using neural networks to approximate our value estimates by mapping from a discrete number of states and actions to a value. In the maze for example, there were 49 states (squares) and 4 actions (move in each adjacent direction). In this environment, we are trying to learn how to balance a ball on a 2 dimensional paddle, by deciding at each time step whether we want to tilt the paddle left or right. Here, the state space becomes continuous (the angle of the paddle, and the position of the ball). The good news is, we can still use Neural Networks to approximate this function!\nA note about off-policy vs on-policy learning: The methods we used previously, are off-policy methods, meaning we can generate data with any strategy(using epsilon greedy for example) and learn from it. On-policy methods can only learn from actions that were taken following our policy (remember, a policy is the method we use to determine which actions to take). This constrains our learning process, as we have to have an exploration strategy that is built in to the policy itself, but allows us to tie results directly to our reasoning, and enables us to learn more efficiently.\nThe approach we will use here is called Policy Gradients, and is an on-policy method. Previously, we were first learning a value function Q for each action in each state and then building a policy on top. In Vanilla Policy Gradient, we still use Monte Carlo Estimates, but we learn our policy directly through a loss function that increases the probability of choosing rewarding actions. Since we are learning on policy, we cannot use methods such as epsilon greedy (which includes random choices), to get our agent to explore the environment. The way that we encourage exploration is by using a method called entropy regularization, which pushes our probability estimates to be wider, and thus will encourage us to make riskier choices to explore the space.\n4+/Leveraging deep learning for representations\nIn practice, many state of the art RL methods require learning both a policy and value estimates. The way we do this with deep learning is by having both be two separate outputs of the same backbone neural network, which will make it easier for our neural network to learn good representations.\nOne method to do this is Advantage Actor Critic (A2C). We learn our policy directly with policy gradients (defined above), and learn a value function using something called Advantage. Instead of updating our value function based on rewards, we update it based on our advantage, which measures how much better or worse an action was than our previous value function estimated it to be. This helps make learning more stable compared to simple Q Learning and Vanilla Policy Gradients.\n5/Learning directly from the screen\nThere is an additional advantage to using Deep Learning for these methods, which is that Deep Neural Networks excel at perceptive tasks. When a human plays a game, the information received is not a list of states, but an image (usually of a screen, or a board, or the surrounding environment).\nImage-based Learning combines a Convolutional Neural Network (CNN) with RL. In this environment, we pass in a raw image instead of features, and add a 2 layer CNN to our architecture without changing anything else! We can even inspect activations to see what the network picks up on to determine value, and policy. In the example below, we can see that the network uses the current score and distant obstacles to estimate the value of the current state, while focusing on nearby obstacles for determining actions. Neat!\nAs a side note, while toying around with the provided implementation, I\u2019ve found that visual learning is very sensitive to hyperparameters. Changing the discount rate slightly for example, completely prevented the neural network from learning even on a toy application. This is a widely known problem, but it is interesting to see it first hand.\n6/Nuanced actions\nSo far, we\u2019ve played with environments with continuous and discrete state spaces. However, every environment we studied had a discrete action space: we could move in one of four directions, or tilt the paddle to the left or right. Ideally, for applications such as self-driving cars, we would like to learn continuous actions, such as turning the steering wheel between 0 and 360 degrees. In this environment called 3D ball world, we can choose to tilt the paddle to any value on each of its axes. This gives us more control as to how we perform actions, but makes the action space much larger.\nWe can approach this by approximating our potential choices with Gaussian distributions. We learn a probability distribution over potential actions by learning the mean and variance of a Gaussian distribution, and our policy we sample from that distribution. Simple, in theory :).\n7/Next steps for the brave\nThere are a few concepts that separate the algorithms described above from state of the art approaches. It\u2019s interesting to see that conceptually, the best robotics and game-playing algorithms are not that far away from the ones we just explored:\nThat\u2019s it for this overview, I hope this has been informative and fun! If you are looking to dive deeper into the theory of RL, give Arthur\u2019s posts a read, or diving deeper by following David Silver\u2019s UCL course. If you are looking to learn more about the projects we do at Insight, or how we work with companies, please check us out below, or reach out to me here.\nWant to learn about applied Artificial Intelligence from leading practitioners in Silicon Valley, New York, or Toronto? Learn more about the Insight Artificial Intelligence Fellows Program.\nAre you a company working in AI and would like to get involved in the Insight AI Fellows Program? Feel free to get in touch.\nFrom a quick cheer to a standing ovation, clap to show how much you enjoyed this story.\nAI Lead at Insight AI @EmmanuelAmeisen\nInsight Fellows Program - Your bridge to a career in data"
    },
    {
        "author": "Irhum Shafkat",
        "link": "https://towardsdatascience.com/intuitively-understanding-convolutions-for-deep-learning-1f6f42faee1?source=---------5----------------",
        "title": "Intuitively Understanding Convolutions for Deep Learning",
        "text": "The advent of powerful and versatile deep learning frameworks in recent years has made it possible to implement convolution layers into a deep learning model an extremely simple task, often achievable in a single line of code.\nHowever, understanding convolutions, especially for the first time can often feel a bit unnerving, with terms like kernels, filters, channels and so on all stacked onto each other. Yet, convolutions as a concept are fascinatingly powerful and highly extensible, and in this post, we\u2019ll break down the mechanics of the convolution operation, step-by-step, relate it to the standard fully connected network, and explore just how they build up a strong visual hierarchy, making them powerful feature extractors for images.\nThe 2D convolution is a fairly simple operation at heart: you start with a kernel, which is simply a small matrix of weights. This kernel \u201cslides\u201d over the 2D input data, performing an elementwise multiplication with the part of the input it is currently on, and then summing up the results into a single output pixel.\nThe kernel repeats this process for every location it slides over, converting a 2D matrix of features into yet another 2D matrix of features. The output features are essentially, the weighted sums (with the weights being the values of the kernel itself) of the input features located roughly in the same location of the output pixel on the input layer.\nWhether or not an input feature falls within this \u201croughly same location\u201d, gets determined directly by whether it\u2019s in the area of the kernel that produced the output or not. This means the size of the kernel directly determines how many (or few) input features get combined in the production of a new output feature.\nThis is all in pretty stark contrast to a fully connected layer. In the above example, we have 5\u00d75=25 input features, and 3\u00d73=9 output features. If this were a standard fully connected layer, you\u2019d have a weight matrix of 25\u00d79 = 225 parameters, with every output feature being the weighted sum of every single input feature. Convolutions allow us to do this transformation with only 9 parameters, with each output feature, instead of \u201clooking at\u201d every input feature, only getting to \u201clook\u201d at input features coming from roughly the same location. Do take note of this, as it\u2019ll be critical to our later discussion.\nBefore we move on, it\u2019s definitely worth looking into two techniques that are commonplace in convolution layers: Padding and Strides.\nPadding does something pretty clever to solve this: pad the edges with extra, \u201cfake\u201d pixels (usually of value 0, hence the oft-used term \u201czero padding\u201d). This way, the kernel when sliding can allow the original edge pixels to be at its center, while extending into the fake pixels beyond the edge, producing an output the same size as the input.\nThe idea of the stride is to skip some of the slide locations of the kernel. A stride of 1 means to pick slides a pixel apart, so basically every single slide, acting as a standard convolution. A stride of 2 means picking slides 2 pixels apart, skipping every other slide in the process, downsizing by roughly a factor of 2, a stride of 3 means skipping every 2 slides, downsizing roughly by factor 3, and so on.\nMore modern networks, such as the ResNet architectures entirely forgo pooling layers in their internal layers, in favor of strided convolutions when needing to reduce their output sizes.\nOf course, the diagrams above only deals with the case where the image has a single input channel. In practicality, most input images have 3 channels, and that number only increases the deeper you go into a network. It\u2019s pretty easy to think of channels, in general, as being a \u201cview\u201d of the image as a whole, emphasising some aspects, de-emphasising others.\nSo this is where a key distinction between terms comes in handy: whereas in the 1 channel case, where the term filter and kernel are interchangeable, in the general case, they\u2019re actually pretty different. Each filter actually happens to be a collection of kernels, with there being one kernel for every single input channel to the layer, and each kernel being unique.\nEach filter in a convolution layer produces one and only one output channel, and they do it like so:\nEach of the kernels of the filter \u201cslides\u201d over their respective input channels, producing a processed version of each. Some kernels may have stronger weights than others, to give more emphasis to certain input channels than others (eg. a filter may have a red kernel channel with stronger weights than others, and hence, respond more to differences in the red channel features than the others).\nEach of the per-channel processed versions are then summed together to form one channel. The kernels of a filter each produce one version of each channel, and the filter as a whole produces one overall output channel.\nFinally, then there\u2019s the bias term. The way the bias term works here is that each output filter has one bias term. The bias gets added to the output channel so far to produce the final output channel.\nAnd with the single filter case down, the case for any number of filters is identical: Each filter processes the input with its own, different set of kernels and a scalar bias with the process described above, producing a single output channel. They are then concatenated together to produce the overall output, with the number of output channels being the number of filters. A nonlinearity is then usually applied before passing this as input to another convolution layer, which then repeats this process.\nEven with the mechanics of the convolution layer down, it can still be hard to relate it back to a standard feed-forward network, and it still doesn\u2019t explain why convolutions scale to, and work so much better for image data.\nSuppose we have a 4\u00d74 input, and we want to transform it into a 2\u00d72 grid. If we were using a feedforward network, we\u2019d reshape the 4\u00d74 input into a vector of length 16, and pass it through a densely connected layer with 16 inputs and 4 outputs. One could visualize the weight matrix W for a layer:\nAnd although the convolution kernel operation may seem a bit strange at first, it is still a linear transformation with an equivalent transformation matrix. If we were to use a kernel K of size 3 on the reshaped 4\u00d74 input to get a 2\u00d72 output, the equivalent transformation matrix would be:\n(Note: while the above matrix is an equivalent transformation matrix, the actual operation is usually implemented as a very different matrix multiplication[2])\nThe convolution then, as a whole, is still a linear transformation, but at the same time it\u2019s also a dramatically different kind of transformation. For a matrix with 64 elements, there\u2019s just 9 parameters which themselves are reused several times. Each output node only gets to see a select number of inputs (the ones inside the kernel). There is no interaction with any of the other inputs, as the weights to them are set to 0.\nIt\u2019s useful to see the convolution operation as a hard prior on the weight matrix. In this context, by prior, I mean predefined network parameters. For example, when you use a pretrained model for image classification, you use the pretrained network parameters as your prior, as a feature extractor to your final densely connected layer.\nIn that sense, there\u2019s a direct intuition between why both are so efficient (compared to their alternatives). Transfer learning is efficient by orders of magnitude compared to random initialization, because you only really need to optimize the parameters of the final fully connected layer, which means you can have fantastic performance with only a few dozen images per class.\nHere, you don\u2019t need to optimize all 64 parameters, because we set most of them to zero (and they\u2019ll stay that way), and the rest we convert to shared parameters, resulting in only 9 actual parameters to optimize. This efficiency matters, because when you move from the 784 inputs of MNIST to real world 224\u00d7224\u00d73 images, thats over 150,000 inputs. A dense layer attempting to halve the input to 75,000 inputs would still require over 10 billion parameters. For comparison, the entirety of ResNet-50 has some 25 million parameters.\nSo fixing some parameters to 0, and tying parameters increases efficiency, but unlike the transfer learning case, where we know the prior is good because it works on a large general set of images, how do we know this is any good?\nThe answer lies in the feature combinations the prior leads the parameters to learn.\nEarly on in this article, we discussed that:\nSo with backpropagation coming in all the way from the classification nodes of the network, the kernels have the interesting task of learning weights to produce features only from a set of local inputs. Additionally, because the kernel itself is applied across the entire image, the features the kernel learns must be general enough to come from any part of the image.\nIf this were any other kind of data, eg. categorical data of app installs, this would\u2019ve been a disaster, for just because your number of app installs and app type columns are next to each other doesn\u2019t mean they have any \u201clocal, shared features\u201d common with app install dates and time used. Sure, the four may have an underlying higher level feature (eg. which apps people want most) that can be found, but that gives us no reason to believe the parameters for the first two are exactly the same as the parameters for the latter two. The four could\u2019ve been in any (consistent) order and still be valid!\nPixels however, always appear in a consistent order, and nearby pixels influence a pixel e.g. if all nearby pixels are red, it\u2019s pretty likely the pixel is also red. If there are deviations, that\u2019s an interesting anomaly that could be converted into a feature, and all this can be detected from comparing a pixel with its neighbors, with other pixels in its locality.\nAnd this idea is really what a lot of earlier computer vision feature extraction methods were based around. For instance, for edge detection, one can use a Sobel edge detection filter, a kernel with fixed parameters, operating just like the standard one-channel convolution:\nFor a non-edge containing grid (eg. the background sky), most of the pixels are the same value, so the overall output of the kernel at that point is 0. For a grid with an vertical edge, there is a difference between the pixels to the left and right of the edge, and the kernel computes that difference to be non-zero, activating and revealing the edges. The kernel only works only a 3\u00d73 grids at a time, detecting anomalies on a local scale, yet when applied across the entire image, is enough to detect a certain feature on a global scale, anywhere in the image!\nSo the key difference we make with deep learning is ask this question: Can useful kernels be learnt? For early layers operating on raw pixels, we could reasonably expect feature detectors of fairly low level features, like edges, lines, etc.\nThere\u2019s an entire branch of deep learning research focused on making neural network models interpretable. One of the most powerful tools to come out of that is Feature Visualization using optimization[3]. The idea at core is simple: optimize a image (usually initialized with random noise) to activate a filter as strongly as possible. This does make intuitive sense: if the optimized image is completely filled with edges, that\u2019s strong evidence that\u2019s what the filter itself is looking for and is activated by. Using this, we can peek into the learnt filters, and the results are stunning:\nOne important thing to notice here is that convolved images are still images. The output of a small grid of pixels from the top left of an image will still be on the top left. So you can run another convolution layer on top of another (such as the two on the left) to extract deeper features, which we visualize.\nYet, however deep our feature detectors get, without any further changes they\u2019ll still be operating on very small patches of the image. No matter how deep your detectors are, you can\u2019t detect faces from a 3\u00d73 grid. And this is where the idea of the receptive field comes in.\nA essential design choice of any CNN architecture is that the input sizes grow smaller and smaller from the start to the end of the network, while the number of channels grow deeper. This, as mentioned earlier, is often done through strides or pooling layers. Locality determines what inputs from the previous layer the outputs get to see. The receptive field determines what area of the original input to the entire network the output gets to see.\nThe idea of a strided convolution is that we only process slides a fixed distance apart, and skip the ones in the middle. From a different point of view, we only keep outputs a fixed distance apart, and remove the rest[1].\nWe then apply a nonlinearity to the output, and per usual, then stack another new convolution layer on top. And this is where things get interesting. Even if were we to apply a kernel of the same size (3\u00d73), having the same local area, to the output of the strided convolution, the kernel would have a larger effective receptive field:\nThis is because the output of the strided layer still does represent the same image. It is not so much cropping as it is resizing, only thing is that each single pixel in the output is a \u201crepresentative\u201d of a larger area (of whose other pixels were discarded) from the same rough location from the original input. So when the next layer\u2019s kernel operates on the output, it\u2019s operating on pixels collected from a larger area.\n(Note: if you\u2019re familiar with dilated convolutions, note that the above is not a dilated convolution. Both are methods of increasing the receptive field, but dilated convolutions are a single layer, while this takes place on a regular convolution following a strided convolution, with a nonlinearity inbetween)\nThis expansion of the receptive field allows the convolution layers to combine the low level features (lines, edges), into higher level features (curves, textures), as we see in the mixed3a layer.\nFollowed by a pooling/strided layer, the network continues to create detectors for even higher level features (parts, patterns), as we see for mixed4a.\nThe repeated reduction in image size across the network results in, by the 5th block on convolutions, input sizes of just 7\u00d77, compared to inputs of 224\u00d7224. At this point, each single pixel represents a grid of 32\u00d732 pixels, which is huge.\nCompared to earlier layers, where an activation meant detecting an edge, here, an activation on the tiny 7\u00d77 grid is one for a very high level feature, such as for birds.\nThe network as a whole progresses from a small number of filters (64 in case of GoogLeNet), detecting low level features, to a very large number of filters(1024 in the final convolution), each looking for an extremely specific high level feature. Followed by a final pooling layer, which collapses each 7\u00d77 grid into a single pixel, each channel is a feature detector with a receptive field equivalent to the entire image.\nCompared to what a standard feedforward network would have done, the output here is really nothing short of awe-inspiring. A standard feedforward network would have produced abstract feature vectors, from combinations of every single pixel in the image, requiring intractable amounts of data to train.\nThe CNN, with the priors imposed on it, starts by learning very low level feature detectors, and as across the layers as its receptive field is expanded, learns to combine those low-level features into progressively higher level features; not an abstract combination of every single pixel, but rather, a strong visual hierarchy of concepts.\nBy detecting low level features, and using them to detect higher level features as it progresses up its visual hierarchy, it is eventually able to detect entire visual concepts such as faces, birds, trees, etc, and that\u2019s what makes them such powerful, yet efficient with image data.\nWith the visual hierarchy CNNs build, it is pretty reasonable to assume that their vision systems are similar to humans. And they\u2019re really great with real world images, but they also fail in ways that strongly suggest their vision systems aren\u2019t entirely human-like. The most major problem: Adversarial Examples[4], examples which have been specifically modified to fool the model.\nAdversarial examples would be a non-issue if the only tampered ones that caused the models to fail were ones that even humans would notice. The problem is, the models are susceptible to attacks by samples which have only been tampered with ever so slightly, and would clearly not fool any human. This opens the door for models to silently fail, which can be pretty dangerous for a wide range of applications from self-driving cars to healthcare.\nRobustness against adversarial attacks is currently a highly active area of research, the subject of many papers and even competitions, and solutions will certainly improve CNN architectures to become safer and more reliable.\nCNNs were the models that allowed computer vision to scale from simple applications to powering sophisticated products and services, ranging from face detection in your photo gallery to making better medical diagnoses. They might be the key method in computer vision going forward, or some other new breakthrough might just be around the corner. Regardless, one thing is for sure: they\u2019re nothing short of amazing, at the heart of many present-day innovative applications, and are most certainly worth deeply understanding.\nHope you enjoyed this article! If you\u2019d like to stay connected, you\u2019ll find me on Twitter here. If you have a question, comments are welcome! \u2014 I find them to be useful to my own learning process as well.\nFrom a quick cheer to a standing ovation, clap to show how much you enjoyed this story.\nCurious programmer, tinkers around in Python and deep learning.\nSharing concepts, ideas, and codes."
    }
]